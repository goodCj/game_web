{"ast":null,"code":"import _toConsumableArray from \"/Users/liusu/Desktop/h5_free/game/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/liusu/Desktop/h5_free/game/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport React, { useRef } from 'react';\nimport { useSpring, animated } from '@react-spring/web';\nimport { useSize } from 'ahooks';\nimport { rubberbandIfOutOfBounds } from '../../utils/rubberband';\nimport { useDragAndPinch } from '../../utils/use-drag-and-pinch';\nimport { bound } from '../../utils/bound';\nimport * as mat from '../../utils/matrix';\nvar classPrefix = \"adm-image-viewer\";\nexport var Slide = function Slide(props) {\n  var dragLockRef = props.dragLockRef,\n    maxZoom = props.maxZoom;\n  var controlRef = useRef(null);\n  var imgRef = useRef(null);\n  var _useSpring = useSpring(function () {\n      return {\n        matrix: mat.create(),\n        config: {\n          tension: 200\n        }\n      };\n    }),\n    _useSpring2 = _slicedToArray(_useSpring, 2),\n    matrix = _useSpring2[0].matrix,\n    api = _useSpring2[1];\n  var controlSize = useSize(controlRef);\n  var imgSize = useSize(imgRef);\n  var pinchLockRef = useRef(false);\n  var boundMatrix = function boundMatrix(nextMatrix, type) {\n    var last = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!controlSize || !imgSize) return nextMatrix;\n    var controlLeft = -controlSize.width / 2;\n    var controlTop = -controlSize.height / 2;\n    var imgLeft = -imgSize.width / 2;\n    var imgTop = -imgSize.height / 2;\n    var zoom = mat.getScaleX(nextMatrix);\n    var scaledImgWidth = zoom * imgSize.width;\n    var scaledImgHeight = zoom * imgSize.height;\n    var _mat$apply = mat.apply(nextMatrix, [imgLeft, imgTop]),\n      _mat$apply2 = _slicedToArray(_mat$apply, 2),\n      x = _mat$apply2[0],\n      y = _mat$apply2[1];\n    if (type === 'translate') {\n      var boundedX = x;\n      var boundedY = y;\n      if (scaledImgWidth > controlSize.width) {\n        var minX = controlLeft - (scaledImgWidth - controlSize.width);\n        var maxX = controlLeft;\n        boundedX = last ? bound(x, minX, maxX) : rubberbandIfOutOfBounds(x, minX, maxX, zoom * 50);\n      } else {\n        boundedX = -scaledImgWidth / 2;\n      }\n      if (scaledImgHeight > controlSize.height) {\n        var minY = controlTop - (scaledImgHeight - controlSize.height);\n        var maxY = controlTop;\n        boundedY = last ? bound(y, minY, maxY) : rubberbandIfOutOfBounds(y, minY, maxY, zoom * 50);\n      } else {\n        boundedY = -scaledImgHeight / 2;\n      }\n      return mat.translate(nextMatrix, boundedX - x, boundedY - y);\n    }\n    if (type === 'scale' && last) {\n      var _boundedX = scaledImgWidth > controlSize.width ? bound(x, controlLeft - (scaledImgWidth - controlSize.width), controlLeft) : -scaledImgWidth / 2,\n        _boundedY = scaledImgHeight > controlSize.height ? bound(y, controlTop - (scaledImgHeight - controlSize.height), controlTop) : -scaledImgHeight / 2;\n      return mat.translate(nextMatrix, _boundedX - x, _boundedY - y);\n    }\n    return nextMatrix;\n  };\n  useDragAndPinch({\n    onDrag: function onDrag(state) {\n      if (state.first) return;\n      if (state.pinching) return state.cancel();\n      if (state.tap && state.elapsedTime > 0 && state.elapsedTime < 1000) {\n        // 判断点击时间>0是为了过滤掉非正常操作，例如用户长按选择图片之后的取消操作（也是一次点击）\n        props.onTap();\n        return;\n      }\n      var currentZoom = mat.getScaleX(matrix.get());\n      if (dragLockRef) {\n        dragLockRef.current = currentZoom !== 1;\n      }\n      if (!pinchLockRef.current && currentZoom <= 1) {\n        api.start({\n          matrix: mat.create()\n        });\n      } else {\n        var currentMatrix = matrix.get();\n        var offset = [state.offset[0] - mat.getTranslateX(currentMatrix), state.offset[1] - mat.getTranslateY(currentMatrix)];\n        var nextMatrix = mat.translate.apply(mat, [currentMatrix].concat(_toConsumableArray(state.last ? [offset[0] + state.velocity[0] * state.direction[0] * 200, offset[1] + state.velocity[1] * state.direction[1] * 200] : offset)));\n        api.start({\n          matrix: boundMatrix(nextMatrix, 'translate', state.last),\n          immediate: !state.last\n        });\n      }\n    },\n    onPinch: function onPinch(state) {\n      var _a;\n      pinchLockRef.current = !state.last;\n      var _state$offset = _slicedToArray(state.offset, 1),\n        d = _state$offset[0];\n      if (d < 0) return;\n      var mergedMaxZoom;\n      if (maxZoom === 'auto') {\n        mergedMaxZoom = controlSize && imgSize ? Math.max(controlSize.height / imgSize.height, controlSize.width / imgSize.width) : 1;\n      } else {\n        mergedMaxZoom = maxZoom;\n      }\n      var nextZoom = state.last ? bound(d, 1, mergedMaxZoom) : d;\n      (_a = props.onZoomChange) === null || _a === void 0 ? void 0 : _a.call(props, nextZoom);\n      if (state.last && nextZoom <= 1) {\n        api.start({\n          matrix: mat.create()\n        });\n        if (dragLockRef) {\n          dragLockRef.current = false;\n        }\n      } else {\n        if (!controlSize) return;\n        var currentMatrix = matrix.get();\n        var currentZoom = mat.getScaleX(currentMatrix);\n        var originOffsetX = state.origin[0] - controlSize.width / 2;\n        var originOffsetY = state.origin[1] - controlSize.height / 2;\n        var nextMatrix = mat.translate(currentMatrix, -originOffsetX, -originOffsetY);\n        nextMatrix = mat.scale(nextMatrix, nextZoom / currentZoom);\n        nextMatrix = mat.translate(nextMatrix, originOffsetX, originOffsetY);\n        api.start({\n          matrix: boundMatrix(nextMatrix, 'scale', state.last),\n          immediate: !state.last\n        });\n        if (dragLockRef) {\n          dragLockRef.current = true;\n        }\n      }\n    }\n  }, {\n    target: controlRef,\n    drag: {\n      // filterTaps: true,\n      from: function from() {\n        return [mat.getTranslateX(matrix.get()), mat.getTranslateY(matrix.get())];\n      },\n      pointer: {\n        touch: true\n      }\n    },\n    pinch: {\n      from: function from() {\n        return [mat.getScaleX(matrix.get()), 0];\n      },\n      pointer: {\n        touch: true\n      }\n    }\n  });\n  return React.createElement(\"div\", {\n    className: \"\".concat(classPrefix, \"-slide\"),\n    onPointerMove: function onPointerMove(e) {\n      if (mat.getScaleX(matrix.get()) !== 1) {\n        e.stopPropagation();\n      }\n    }\n  }, React.createElement(\"div\", {\n    className: \"\".concat(classPrefix, \"-control\"),\n    ref: controlRef\n  }, React.createElement(animated.div, {\n    className: \"\".concat(classPrefix, \"-image-wrapper\"),\n    style: {\n      matrix: matrix\n    }\n  }, React.createElement(\"img\", {\n    ref: imgRef,\n    src: props.image,\n    draggable: false,\n    alt: props.image\n  }))));\n};","map":{"version":3,"names":["React","useRef","useSpring","animated","useSize","rubberbandIfOutOfBounds","useDragAndPinch","bound","mat","classPrefix","Slide","props","dragLockRef","maxZoom","controlRef","imgRef","_useSpring","matrix","create","config","tension","_useSpring2","_slicedToArray","api","controlSize","imgSize","pinchLockRef","boundMatrix","nextMatrix","type","last","arguments","length","undefined","controlLeft","width","controlTop","height","imgLeft","imgTop","zoom","getScaleX","scaledImgWidth","scaledImgHeight","_mat$apply","apply","_mat$apply2","x","y","boundedX","boundedY","minX","maxX","minY","maxY","translate","onDrag","state","first","pinching","cancel","tap","elapsedTime","onTap","currentZoom","get","current","start","currentMatrix","offset","getTranslateX","getTranslateY","concat","_toConsumableArray","velocity","direction","immediate","onPinch","_a","_state$offset","d","mergedMaxZoom","Math","max","nextZoom","onZoomChange","call","originOffsetX","origin","originOffsetY","scale","target","drag","from","pointer","touch","pinch","createElement","className","onPointerMove","e","stopPropagation","ref","div","style","src","image","draggable","alt"],"sources":["/Users/liusu/Desktop/h5_free/game/node_modules/antd-mobile/es/components/image-viewer/slide.js"],"sourcesContent":["import React, { useRef } from 'react';\nimport { useSpring, animated } from '@react-spring/web';\nimport { useSize } from 'ahooks';\nimport { rubberbandIfOutOfBounds } from '../../utils/rubberband';\nimport { useDragAndPinch } from '../../utils/use-drag-and-pinch';\nimport { bound } from '../../utils/bound';\nimport * as mat from '../../utils/matrix';\nconst classPrefix = `adm-image-viewer`;\nexport const Slide = props => {\n  const {\n    dragLockRef,\n    maxZoom\n  } = props;\n  const controlRef = useRef(null);\n  const imgRef = useRef(null);\n  const [{\n    matrix\n  }, api] = useSpring(() => ({\n    matrix: mat.create(),\n    config: {\n      tension: 200\n    }\n  }));\n  const controlSize = useSize(controlRef);\n  const imgSize = useSize(imgRef);\n  const pinchLockRef = useRef(false);\n  const boundMatrix = (nextMatrix, type, last = false) => {\n    if (!controlSize || !imgSize) return nextMatrix;\n    const controlLeft = -controlSize.width / 2;\n    const controlTop = -controlSize.height / 2;\n    const imgLeft = -imgSize.width / 2;\n    const imgTop = -imgSize.height / 2;\n    const zoom = mat.getScaleX(nextMatrix);\n    const scaledImgWidth = zoom * imgSize.width;\n    const scaledImgHeight = zoom * imgSize.height;\n    const [x, y] = mat.apply(nextMatrix, [imgLeft, imgTop]);\n    if (type === 'translate') {\n      let boundedX = x;\n      let boundedY = y;\n      if (scaledImgWidth > controlSize.width) {\n        const minX = controlLeft - (scaledImgWidth - controlSize.width);\n        const maxX = controlLeft;\n        boundedX = last ? bound(x, minX, maxX) : rubberbandIfOutOfBounds(x, minX, maxX, zoom * 50);\n      } else {\n        boundedX = -scaledImgWidth / 2;\n      }\n      if (scaledImgHeight > controlSize.height) {\n        const minY = controlTop - (scaledImgHeight - controlSize.height);\n        const maxY = controlTop;\n        boundedY = last ? bound(y, minY, maxY) : rubberbandIfOutOfBounds(y, minY, maxY, zoom * 50);\n      } else {\n        boundedY = -scaledImgHeight / 2;\n      }\n      return mat.translate(nextMatrix, boundedX - x, boundedY - y);\n    }\n    if (type === 'scale' && last) {\n      const [boundedX, boundedY] = [scaledImgWidth > controlSize.width ? bound(x, controlLeft - (scaledImgWidth - controlSize.width), controlLeft) : -scaledImgWidth / 2, scaledImgHeight > controlSize.height ? bound(y, controlTop - (scaledImgHeight - controlSize.height), controlTop) : -scaledImgHeight / 2];\n      return mat.translate(nextMatrix, boundedX - x, boundedY - y);\n    }\n    return nextMatrix;\n  };\n  useDragAndPinch({\n    onDrag: state => {\n      if (state.first) return;\n      if (state.pinching) return state.cancel();\n      if (state.tap && state.elapsedTime > 0 && state.elapsedTime < 1000) {\n        // 判断点击时间>0是为了过滤掉非正常操作，例如用户长按选择图片之后的取消操作（也是一次点击）\n        props.onTap();\n        return;\n      }\n      const currentZoom = mat.getScaleX(matrix.get());\n      if (dragLockRef) {\n        dragLockRef.current = currentZoom !== 1;\n      }\n      if (!pinchLockRef.current && currentZoom <= 1) {\n        api.start({\n          matrix: mat.create()\n        });\n      } else {\n        const currentMatrix = matrix.get();\n        const offset = [state.offset[0] - mat.getTranslateX(currentMatrix), state.offset[1] - mat.getTranslateY(currentMatrix)];\n        const nextMatrix = mat.translate(currentMatrix, ...(state.last ? [offset[0] + state.velocity[0] * state.direction[0] * 200, offset[1] + state.velocity[1] * state.direction[1] * 200] : offset));\n        api.start({\n          matrix: boundMatrix(nextMatrix, 'translate', state.last),\n          immediate: !state.last\n        });\n      }\n    },\n    onPinch: state => {\n      var _a;\n      pinchLockRef.current = !state.last;\n      const [d] = state.offset;\n      if (d < 0) return;\n      let mergedMaxZoom;\n      if (maxZoom === 'auto') {\n        mergedMaxZoom = controlSize && imgSize ? Math.max(controlSize.height / imgSize.height, controlSize.width / imgSize.width) : 1;\n      } else {\n        mergedMaxZoom = maxZoom;\n      }\n      const nextZoom = state.last ? bound(d, 1, mergedMaxZoom) : d;\n      (_a = props.onZoomChange) === null || _a === void 0 ? void 0 : _a.call(props, nextZoom);\n      if (state.last && nextZoom <= 1) {\n        api.start({\n          matrix: mat.create()\n        });\n        if (dragLockRef) {\n          dragLockRef.current = false;\n        }\n      } else {\n        if (!controlSize) return;\n        const currentMatrix = matrix.get();\n        const currentZoom = mat.getScaleX(currentMatrix);\n        const originOffsetX = state.origin[0] - controlSize.width / 2;\n        const originOffsetY = state.origin[1] - controlSize.height / 2;\n        let nextMatrix = mat.translate(currentMatrix, -originOffsetX, -originOffsetY);\n        nextMatrix = mat.scale(nextMatrix, nextZoom / currentZoom);\n        nextMatrix = mat.translate(nextMatrix, originOffsetX, originOffsetY);\n        api.start({\n          matrix: boundMatrix(nextMatrix, 'scale', state.last),\n          immediate: !state.last\n        });\n        if (dragLockRef) {\n          dragLockRef.current = true;\n        }\n      }\n    }\n  }, {\n    target: controlRef,\n    drag: {\n      // filterTaps: true,\n      from: () => [mat.getTranslateX(matrix.get()), mat.getTranslateY(matrix.get())],\n      pointer: {\n        touch: true\n      }\n    },\n    pinch: {\n      from: () => [mat.getScaleX(matrix.get()), 0],\n      pointer: {\n        touch: true\n      }\n    }\n  });\n  return React.createElement(\"div\", {\n    className: `${classPrefix}-slide`,\n    onPointerMove: e => {\n      if (mat.getScaleX(matrix.get()) !== 1) {\n        e.stopPropagation();\n      }\n    }\n  }, React.createElement(\"div\", {\n    className: `${classPrefix}-control`,\n    ref: controlRef\n  }, React.createElement(animated.div, {\n    className: `${classPrefix}-image-wrapper`,\n    style: {\n      matrix\n    }\n  }, React.createElement(\"img\", {\n    ref: imgRef,\n    src: props.image,\n    draggable: false,\n    alt: props.image\n  }))));\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}